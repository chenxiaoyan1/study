```js
//当前正在工作的hook的指针
let workInProgressHook = null

fiber = {
stateNode:App,
mmemoizedState:null //hook对应的数据，  是一个链表
}
//update环状链表

```

# 预备面试题
- 了解浏览器的事件循环吗？
- 为什么js在浏览器中有事件循环的机制？
>js是单线程的（为什么是单线程的，因为若不是单线程的，两个线程同时操作一个DOM ，会有问题）
>eventloop 实现了非阻塞事件

-  了解事件循环的俩种任务吗？
>宏任务：整体代码，setTimeout,setInterval, I/O操作
>微任务：new Promise().then,mutaionObserver

- 为什么引入微任务的概念，只有宏任务可以吗？
>宏任务，先进先出的原则执行，但是如果有高优先级任务想要执行怎么办，如果都是宏任务，那么高优先级任务后进入后执行，所以引进微任务的概念，当宏任务执行完成后就会去看看有没有微任务，有微任务就执行微任务

-  事件循环机制是什么
>一次宏任务执行完成就会去检查微任务，有就执行，如果微任务执行过程中又有微任务了，也会执行此微任务，直到执行完成

- node的事件循环和浏览器中事件循环的区别


- 3个事件循环的题，见代码

- 事件的捕获冒泡机制
>捕获：自顶向下 ,window到目标元素
>冒泡：从下向上，目标元素到window

-  window.addEventListener监听的是什么事件
>看第三个参数，默认不传，是false 冒泡阶段
>传了，true 是捕获阶段

- 平时有哪些场景用到这个机制
>1)事件委托
2)一个历史页面，上面按钮都有各自的事件，这时给每一个访问的用户添加一个属性banned,为true时此用户点击页面任意按钮或者元素，都不响应原来的函数，而是直接alert,你被封禁了（使用捕获）
```js
window.addEventListener("click",()=>{
if(banned === true){
 e.stopProgagtion()//该方法的作用是阻止捕获和冒泡阶段中当前事件的进一步传播。但是，它不能防止任何默认行为的发生
    // preventDefault 方法，它可以阻止事件触发后默认动作的发生
}
},true)
```

- 工作中，用过防抖和节流吗
基本概念：
防抖：
节流：
- 分别用在什么场景
节流：resize scroll
防抖：input 联想
- 手写节流函数 

- 你了解Promise吗，平时用的多吗？Promise.all你知道有什么特性吗？
>promise是在创建的时候就执行了
>promisse.all 接收一个数组，数组里面可以不都是promise对象，可以是常量，当都成功时返回结>果，只要有一个报错就会catch，其他promise会执行的，因为promise在创建的 时候就执行了

- 手写promise.all
见文件

- 算法
 接雨水问题

 - 有做过前端优化相关的工作吗，都做过哪些努力
前端优化的目的：
先说一下项目为什么要进行前端优化了，是遇到什么问题了吗，针对问题说优化方案
首屏事件
首次可交互时间
首次有意义内容渲染时间

1、只请求当前需要的资源
异步加载，懒加载，
2、缩减资源体积
打包压缩，gzip (nginx打开开关)，
图片格式的优化：根绝屏幕分辨率展示不同分辨率的图片，图片压缩，webp
尽量控制cooki的大小，同域名请求携带cookie，如果大，耗费体积，尽量减少
3、时序优化
例如promis.all
ssr
prefetch,prerender,preload(预加载，当图片优先级很高时，可以预加载)
4、合理利用缓存
cdn cdn预热 cdn刷新

- 如果一段j s执行时间非常长，怎么分析是哪里时间长
装饰器
见老师代码

- 



- 平时关注过前端的内存处理吗
- 内存的生命周期：
>内存分配：声明变量，函数，对象的时候，j s会自动分配内存，
>内存使用：调用的时候，使用的时候
>内存回收：使用完毕，垃圾回收机制判断是否回收，

- j s中的垃圾回收机制
1、引用计数垃圾回收
如果a对象对b对象有访问权限，那么a引用b对象， 垃圾回收机制会判断一个对象是否有其他对象引用，如果没有就回收了
有个问题就是循环引用，a引用b，b引用a，不会回收，造成内存泄漏问题
2、标记清除算法
无法达到的对象
在运行的时候给存储在内存中的所有变量加上标记
从根部触发，能触及的对象，把标记清除
那些有标记的就被视为即将要删除的变量
- j s中，常见的内存泄漏
1）全局变量（所以不使用的时候一定要置为null）
2）未被清除的定时器和回调（使用完后要清除）
3）闭包
4）do m的引用
```js
const el ={
image:document.getElementById("image""")
}
document.body.removeChild(document.getElementById("image"))//这里删除do m，但是e l对象中引用依然在内存中，所以要手动置为null
el.image = null
```
- 如何避免内存泄漏
减少不必要的全局变量
使用完数据后，及时解除引用
- 实现sizeOf函数，传入一个参数object，计算这个object占用多少字节
number :8字节，
string：2字节
boolean:4字节


- 聊一下前端http请求相关
- 跨域问题解决方法
j sonp
cors
node正向代理
ngin x反向代理
- 做过全局的请求处理吗，比如统一处理登陆态，统一处理全局错误
axios interceptor request response

- 代码题，你能给xhr(XMLHTTPRequest)添加hook，实现在各个阶段打日志吗

- 平时用过发布订阅模式吗，比如vue的event bus ；node 的eventemitter3


- 算法问题 背包问题











